function [pn, qn, alpha] = subproblem(q0, alpha0, mu, delta, theta, x, y)
    
    % initialize variables
    k = 1;
    diff = 1;
    d = size(theta, 1);
    p = nan(2*d, max_iter);
    q = nan(2*d, max_iter);
    q(:, 1) = q0;
    alpha = nan(2*d, max_iter);
    alpha(:, 1) = alpha0;
    
    while diff > tol && k < max_iter
        [f, g, B] = compute_function_trust(theta, x, y);
        
        grad = zeros(2*d);
        for i = 1:2*d
            grad(i) = g' + B * p(:, i) + mu * (p(:, i) - q(:, i)) - alpha(:, i);
        end
        
        hess = zeros(2*d, 2*d);
        for i = 1:2*d
            hess(i, i) = B(i, i) + mu;
        end
        
        % compute Newton step
        pn = -inv(hess) * grad;
        
        % compute q
        for i = 1:2*d
            q(i, k + 1) = p(i, k + 1) - alpha(i, k)/mu;
            m = max(-delta, theta(
        
        % compute lagrange multiplier alpha
        
        % check if p and q are very close
        diff = p - q;
        
        % iteration counter
    end
end